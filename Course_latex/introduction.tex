\section{Introduction}\label{sec:introduction}

\subsection{Categorization of algorithms}
    Algorithms can be categorized by a number of criteria:
    \begin{itemize}
        \item Whether the input is all available at the beggining or not
            \begin{itemize}
                \item Offline
                \item Online
            \end{itemize}
        \item Whether some choices are randomized or not
            \begin{itemize}
                \item Deterministic
                \item Randomized
                \item Both can be quantum algorithms
            \end{itemize}
        \item How good the algorithm does on some inputs
            \begin{itemize}
                \item Worst-case input
                \item Average-case input
            \end{itemize}
        \item Whether we distribute our algorithms execution among multiple processors or not 
            \begin{itemize}
                \item Single processor
                \item Parallel/Distributed
            \end{itemize}
    \end{itemize}

\subsection{Graphs}
    If $S$ is a set and $k$ is a non-negative integer, then
    \[ \binom{S}{k} = \{ T \st T \subseteq S \wedge \cardinality{T} = k \} \]

    The cardinality of such set is $\cardinality{\binom{S}{2}} = \frac{\cardinality{S}!}{k! (\cardinality{S} - k)!} = \binom{\cardinality{S}}{k}$


    Many algorithms seen in this course solve problems on graphs.
    A graph is $G(V,E)$, where $V$ is the set of vertices and $E$, the set of edges, is $E \subseteq \{ \{ u,v \} \st u,v \in V \wedge u \neq v \} = \binom{V}{2} $.


\subsection{Approximations}
    Most problems during the course are going to be approached in the following manner.
    We have a problem that is NP-Hard (or perhaps NP-Complete), so we don't know how to solve it efficiently.
    What we know how to do is to solve such problems efficiently but approximating the solution; that is, the solution proposed by our algorithm is worse than the optimal solution to the problem.

    How do we denote such approximations?
    If a problem is a \textit{maximization} problem (e.g. a set that has some property and its cardinality is as large as possible) then our approximation algorithm will return something that is smaller than the optimal.
    In this case we denote the approximation as a number smaller than 1, possibly a fraction. For instance, a $\frac{1}{2}$-approximation means that the solution is at least half the optimal solution (e.g. if the optimal is $10$, then our solution is at least 5).

    If a problem is a \textulc{minimization} problem, then we reason in an analogous way. Our algorithm outputs a solution larger than the optimal.
    For instance, a $2$-approximation means that our solution is at most twice as large as the optimal one.

    The approach that will be used in many cases is the following. Given a hard problem, we given an algorithm (possibly randomized) that approximates the solution in polynomial time.
    The algorithm is then analyzed to prove various properties that we are interested in. We ugually prove that the algorithm is an approximation, and how good of an approximation it is.
    In the case of randomized algorithms, it might be that the solution not only is an approximation, it might be just wrong; in those cases we are interested in proving that the probability of an incorrect solution is so small that it can be ignored.


\subsection{Math and CS notions}
    There are some notions about mathematics or computer science, used during the course, that are not part of the program, but are strictly related to many of the things seen, and may be worth explaining quickly.
    
    Such notions are explained at the end of this document, in section \nameref{sec:math_notions}.